package com.curso;

import java.io.IOException;
import java.nio.file.FileSystems;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardWatchEventKinds;
import java.nio.file.WatchEvent;
import java.nio.file.WatchKey;
import java.nio.file.WatchService;
import java.time.Duration;

import org.springframework.stereotype.Component;

import reactor.core.publisher.Flux;
import reactor.core.scheduler.Schedulers;

@Component
public class Flujos {

	//Un flujo para el cual ya tenemos los elementos
	public Flux<String> flux1() {
		Flux<String> stringFlux = Flux.just("hello","doctor","name","continue","yesterday","tomorrow");
		return stringFlux;
	}
	
	//Un flujo que emite un elemento cada periodo de tiempo
	public Flux<Long> flux2(){
		return Flux.interval(Duration.ofSeconds(1));
	}

	//Flujo que indica que el consumidor procesará los elementos utilizando otro hilo
	public Flux<String> flux3() {
		Flux<String> stringFlux = Flux
			.just("hello","doctor","name","continue","yesterday","tomorrow")
			.publishOn(Schedulers.boundedElastic());
		return stringFlux;
	}
			
	public Flux<String> flux4(){
		Flux<String> flux = Flux.generate(
			() -> 1, 
			(state, sink) -> {
				sink.next("Mensaje número: "+state);
				try {
					Thread.sleep(1000);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
				
				if(state>9) {
					sink.complete();
				} 				
				return state+1;
			} 
		);
	
		return flux;
	}

	public Flux<String> flux5() throws IOException{
		
		
        WatchService watchService = FileSystems.getDefault().newWatchService();

        Path path = Paths.get("");

        path.register(watchService, 
					  StandardWatchEventKinds.ENTRY_CREATE, 
					  StandardWatchEventKinds.ENTRY_DELETE, 
					  StandardWatchEventKinds.ENTRY_MODIFY);		
		
		Flux<String> flux = Flux.generate(
			(sink) -> {
		        WatchKey key = null;
				try {
					key = watchService.take();
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
	            for (WatchEvent<?> event : key.pollEvents()) {
	            	sink.next(event.kind()+":"+event.context());
	            }
			} 
		);
	
		return flux;
	}
	
	
	
	
}
